<!doctype html>
<html lang="ru">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Гексагон + треугольник · wobble flow + dual tips</title>
    <style>
        :root{
            --bg-1:#0b0f14;
            --bg-2:#101722;

            --hex-line:#7cc7ff;   /* light blue */
            --tri-line:#19d18f;   /* deep green */
            --symbol:#ffe28d;
            --accent:#7ae6ff;

            --tooltip-bg:rgba(14,18,24,.9);
            --tooltip-text:#eaf2ff;

            --pos:#86efac;        /* light green */
            --pos-bg:rgba(134,239,172,.10);
            --neg:#fecaca;        /* pale red */
            --neg-bg:rgba(254,202,202,.10);

            --stroke-width:4.2;
            --gap:18;
            --hex-radius:220;
            --tri-radius:150;

            --draw-time:1400ms;

            /* фоновые руны — интенсивнее */
            --glyph-min:18px;
            --glyph-max:46px;

            /* used for dash animation; kept defined */
            --x: 0px;
            --dx: 30px;
            --seglen: 120px;
        }

        html,body{height:100%}
        body{
            margin:0; overflow:hidden;
            background:
                    radial-gradient(1200px 700px at 50% -10%, var(--bg-2), transparent 60%),
                    radial-gradient(1200px 700px at 50% 110%, var(--bg-2), transparent 60%),
                    linear-gradient(180deg, var(--bg-1), #080b10 60%, var(--bg-1));
            color:#cfd8e6;
            font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Helvetica Neue",Arial;
        }
        .frame{ position:fixed; inset:0; display:grid; place-items:center; padding:24px; }
        .card{
            position:relative; width:min(100vw,980px); height:min(100vh,720px);
            border:1px solid rgba(255,255,255,.06); border-radius:16px;
            background:linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,.005));
            box-shadow:0 10px 40px rgba(0,0,0,.45), inset 0 1px 0 rgba(255,255,255,.05);
            overflow:hidden;
        }
        .card::after{
            content:""; position:absolute; inset:0;
            background-image:
                    radial-gradient(1px 1px at 20% 30%, rgba(255,255,255,.06), transparent 60%),
                    radial-gradient(1px 1px at 60% 70%, rgba(255,255,255,.06), transparent 60%),
                    radial-gradient(1px 1px at 80% 20%, rgba(255,255,255,.04), transparent 60%);
            mix-blend-mode:overlay; opacity:.12; pointer-events:none;
        }

        /* ===== BACK FLOAT GLYPHS (intense) ===== */
        .float-layer{
            position:absolute; inset:0; pointer-events:none;
            mask-image: radial-gradient(75% 75% at 50% 50%, #000 50%, transparent 100%);
            mix-blend-mode:screen; filter:saturate(1);
        }
        .glyph{
            position:absolute; top:110vh; color:#b7cdff; opacity:.55;
            user-select:none; will-change: top, transform, opacity, filter;
            animation: float linear infinite, twinkle ease-in-out infinite;
            text-shadow: 0 0 8px rgba(122,200,255,.3);
        }
        @keyframes float{
            from{ top:110vh; transform: translateX(0vw) rotate(0deg) }
            to  { top:-20vh;  transform: translateX(var(--dx, 0vw)) rotate(360deg) }
        }
        @keyframes twinkle{
            0%,100%{ opacity:.42; filter:brightness(1) }
            50%{ opacity:.68; filter:brightness(1.15) }
        }

        /* ===== SVG ===== */
        svg{ width:100%; height:100%; display:block; }

        .segment{ fill:none; stroke-linecap:round; stroke-width:var(--stroke-width); }
        /* apply glow then displacement wobble (continuous flow) */
        .hex-stroke{ stroke:var(--hex-line); filter:url(#glowStrong) url(#wavyHex); }
        .tri-stroke{ stroke:var(--tri-line); filter:url(#glowStrong) url(#wavyTri); }

        /* draw-on animation */
        .draw{ animation: dashdraw var(--draw-time) ease-out forwards; }
        @keyframes dashdraw{ from{ stroke-dashoffset: var(--seglen,0) } to{ stroke-dashoffset: 0 } }

        /* vertices / runes */
        .vertex{ cursor:pointer; }
        .hit{ fill:rgba(255,0,0,0) }
        .glow{
            fill:none; stroke:var(--accent); stroke-opacity:.35; stroke-width:11;
            filter:blur(3.5px); opacity:0; transition:opacity .25s ease;
        }
        .rune{ filter: url(#neonSymbol); }
        .rune *{
            vector-effect:non-scaling-stroke;
            stroke-linecap:round; stroke-linejoin:round;
            stroke:var(--symbol); fill:none; stroke-width:2.6;
        }
        .vertex:focus-visible .glow,
        .vertex:hover .glow,
        .vertex.active .glow{ opacity:.9 }
        .vertex.active .rune{ animation:runePulse 2.0s ease-in-out infinite }
        @keyframes runePulse{
            0%,100%{ transform:scale(1) }
            50%{ transform:scale(1.12) }
        }

        /* ===== Tooltip ===== */
        .tooltip{
            position:fixed; display:none; max-width:min(420px, 92vw);
            background:var(--tooltip-bg); color:var(--tooltip-text);
            border:1px solid rgba(255,255,255,.1);
            padding:12px 14px; border-radius:12px;
            box-shadow:0 12px 34px rgba(0,0,0,.5), inset 0 1px 0 rgba(255,255,255,.07);
            z-index:10; pointer-events:none;
            backdrop-filter: blur(7px); -webkit-backdrop-filter: blur(7px);
            transform: translate(-50%,-18px);
        }
        .tooltip::after{
            content:""; position:absolute; left:50%; top:100%;
            width:12px; height:12px; background: var(--tooltip-bg);
            border-right:1px solid rgba(255,255,255,.1); border-bottom:1px solid rgba(255,255,255,.1);
            transform: translate(-50%,-7px) rotate(45deg);
        }
        .tooltip.show{ display:block }
        .tooltip h4{ margin:.1em 0 .25em 0; font-weight:600; font-size:14px; letter-spacing:.02em; }
        .tooltip p{ margin:0; font-size:13px; opacity:.95 }

        /* dual facets */
        .facets{ display:flex; gap:8px; margin-top:8px; }
        .facet{
            padding:8px 10px; border-radius:10px; border:1px solid;
            font-size:13px; line-height:1.35;
        }
        .facet .label{
            display:inline-block; font-size:11px; letter-spacing:.06em;
            font-weight:600; opacity:.9; margin-bottom:4px;
        }
        .facet.pos{ border-color:var(--pos); background:var(--pos-bg); }
        .facet.pos .label{ color:var(--pos); }
        .facet.neg{ border-color:var(--neg); background:var(--neg-bg); }
        .facet.neg .label{ color:var(--neg); }

        .hint{ position:absolute; left:12px; right:12px; bottom:10px; text-align:center; font-size:12px; opacity:.6; user-select:none; }
        .brand{ position:absolute; top:10px; left:14px; font-size:12px; opacity:.5; letter-spacing:.08em }
    </style>
</head>
<body>
<div class="frame">
    <div class="card">
        <div class="brand">Заповеди · демо</div>

        <div class="float-layer" id="floatLayer" aria-hidden="true"></div>
        <div class="tooltip" id="tooltip" role="dialog" aria-live="polite"></div>

        <svg id="scene" viewBox="-500 -360 1000 720" aria-label="Гексагон и треугольник с символами">
            <defs>
                <!-- Сильное свечение для линий -->
                <filter id="glowStrong">
                    <feGaussianBlur stdDeviation="2.8" result="b1"/>
                    <feGaussianBlur stdDeviation="6"   in="SourceGraphic" result="b2"/>
                    <feMerge>
                        <feMergeNode in="b2"/>
                        <feMergeNode in="b1"/>
                        <feMergeNode in="SourceGraphic"/>
                    </feMerge>
                </filter>

                <!-- Organic wobble HEX -->
                <filter id="wavyHex" x="-1200" y="-900" width="2400" height="1800" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
                    <feTurbulence id="tHex" type="fractalNoise" baseFrequency="0.020 0.032" numOctaves="2" seed="17" stitchTiles="stitch" result="noise"/>
                    <feOffset id="shiftHex" in="noise" dx="0" dy="0" result="noiseShifted">
                        <animate attributeName="dx" values="0;240" keyTimes="0;1" dur="24s" repeatCount="indefinite"/>
                        <animate attributeName="dy" values="0;60" keyTimes="0;1" dur="24s" repeatCount="indefinite"/>
                    </feOffset>
                    <feGaussianBlur in="noiseShifted" stdDeviation="0.35" result="snoise"/>
                    <feDisplacementMap in="SourceGraphic" in2="snoise" xChannelSelector="R" yChannelSelector="G" scale="15"/>
                </filter>

                <!-- Organic wobble TRI -->
                <filter id="wavyTri" x="-1200" y="-900" width="2400" height="1800" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
                    <feTurbulence id="tTri" type="fractalNoise" baseFrequency="0.020 0.032" numOctaves="2" seed="29" stitchTiles="stitch" result="noise"/>
                    <feOffset id="shiftTri" in="noise" dx="0" dy="0" result="noiseShifted">
                        <animate attributeName="dx" values="0;240" keyTimes="0;1" dur="24s" repeatCount="indefinite"/>
                        <animate attributeName="dy" values="0;60" keyTimes="0;1" dur="24s" repeatCount="indefinite"/>
                    </feOffset>
                    <feGaussianBlur in="noiseShifted" stdDeviation="0.35" result="snoise"/>
                    <feDisplacementMap in="SourceGraphic" in2="snoise" xChannelSelector="R" yChannelSelector="G" scale="15"/>
                </filter>

                <!-- Неоновая анимация для рун (общая) -->
                <filter id="neonSymbol" color-interpolation-filters="sRGB">
                    <feGaussianBlur stdDeviation="0" in="SourceGraphic" result="src"/>
                    <feGaussianBlur stdDeviation="3" in="SourceGraphic" result="blur"/>
                    <feColorMatrix in="blur" type="matrix" values="
              1 0 0 0 0
              0 1 0 0 0
              0 0 1 0 0
              0 0 0 1 0" result="neon"/>
                    <feMerge>
                        <feMergeNode in="neon"/>
                        <feMergeNode in="src"/>
                    </feMerge>
                </filter>
            </defs>

            <g id="shapes"></g>
            <g id="vertices"></g>
        </svg>

        <div class="hint">Наведите курсор (или нажмите) на символ у вершины. У треугольника подсказка двусторонняя (зелёная/красная).</div>
    </div>
</div>

<script>
    /* ===== Utilities ===== */
    const svg = document.getElementById('scene');
    const shapesLayer = document.getElementById('shapes');
    const verticesLayer = document.getElementById('vertices');
    const tooltipEl = document.getElementById('tooltip');

    const TAU = Math.PI * 2;
    const css = getComputedStyle(document.documentElement);
    const HEX_R = +css.getPropertyValue('--hex-radius');
    const TRI_R = +css.getPropertyValue('--tri-radius');
    const GAP   = +css.getPropertyValue('--gap');

    function regularPolygonPoints(sides, radius, rotationDeg=0){
        const rot = rotationDeg * Math.PI / 180;
        return Array.from({length:sides},(_,i)=>{
            const a = rot + i * TAU / sides;
            return { x: radius*Math.cos(a), y: radius*Math.sin(a) };
        });
    }
    function shortenSegment(p1,p2, gap){
        const dx=p2.x-p1.x, dy=p2.y-p1.y;
        const len=Math.hypot(dx,dy);
        const ux=dx/len,  uy=dy/len;
        return [
            { x: p1.x + ux*gap, y: p1.y + uy*gap },
            { x: p2.x - ux*gap, y: p2.y - uy*gap },
        ];
    }
    function pathSegment(a,b, cls){
        const d = `M ${a.x} ${a.y} L ${b.x} ${b.y}`;
        const p = document.createElementNS("http://www.w3.org/2000/svg","path");
        p.setAttribute("d", d);
        p.setAttribute("class", `segment ${cls} draw`);
        const len = Math.hypot(b.x-a.x, b.y-a.y);
        p.style.strokeDasharray = `${len}`;
        p.style.setProperty('--seglen', len);
        p.style.strokeDashoffset = `${len}`;
        return p;
    }

    /* ===== Build shapes ===== */
    const hexPts = regularPolygonPoints(6, HEX_R, 0);   // flat-top hex
    const triPts = regularPolygonPoints(3, TRI_R, -90);  // upward triangle

    function drawShortSides(points, cls){
        for(let i=0;i<points.length;i++){
            const a = points[i];
            const b = points[(i+1)%points.length];
            const [s,e] = shortenSegment(a,b,GAP);
            shapesLayer.appendChild(pathSegment(s,e, cls));
        }
    }
    drawShortSides(hexPts, 'hex-stroke');
    drawShortSides(triPts, 'tri-stroke');

    /* ===== Runes + tips ===== */
    function svgEl(name, attrs={}){
        const el = document.createElementNS("http://www.w3.org/2000/svg", name);
        for(const k in attrs) el.setAttribute(k, attrs[k]);
        return el;
    }
    const runes = {
        eye(g,size=14){ const s=size/12; g.append(svgEl('ellipse',{cx:0,cy:0,rx:10*s,ry:6*s}), svgEl('circle',{cx:0,cy:0,r:2.5*s})); },
        diamond(g,size=14){ const r=size; g.append(svgEl('polygon',{points:`0,-${r} ${r},0 0,${r} -${r},0`})); },
        tri(g,size=14){ const r=size; g.append(svgEl('polygon',{points:`0,-${r} ${r},${r} -${r},${r}`})); },
        star4(g,size=12){ const s=size; g.append(svgEl('line',{x1:-s,y1:0,x2:s,y2:0}), svgEl('line',{x1:0,y1:-s,x2:0,y2:s})); },
        key(g,size=12){ const s=size; g.append(svgEl('circle',{cx:-s*.3, cy:0, r:s*.4}), svgEl('line',{x1:s*.1,y1:0,x2:s,y2:0}), svgEl('line',{x1:s*.75,y1:-s*.25,x2:s*.75,y2:s*.25})); },
        spiral(g,size=12){ const r=size; const d=[`M ${-r*0.6} 0`,`a ${r*0.6} ${r*0.6} 0 1 0 ${r*1.2} 0`,`a ${r*0.35} ${r*0.35} 0 1 1 ${-r*0.7} 0`].join(' '); g.append(svgEl('path',{d})); }
    };
    const runeOrder = ['eye','diamond','tri','star4','key','spiral'];

    const hexTips = [
        {title:'Северная грань', text:[
                'Человек улыбается людям',
                'Пчелу среди роя победить сложнее, чем дракона в лесу',
            ]
        },
        {title:'Северо-восточная', text:[
                'Человек принимает слабость',
                'Болезнь — это не выбор, неудача — это не ошибка',
            ]},
        {title:'Юго-восточная', text:[
                'Человек ценит радость',
                'Смех облегчает любую ношу, песня сокращает долгий путь',
            ]},
        {title:'Южная грань', text:[
                'Человек ловит мимолётное',
                'Тепло костра не унести в сумке, свежий хлеб не станет вкуснее завтра',
            ]},
        {title:'Юго-западная', text:[
                'Человек уважает быт',
                'Каждый шаг требует опоры, каждый бой кончается полевой кухней',
            ]},
        {title:'Северо-западная', text:[
                'Человек позволяет себе отдых',
                'Сгоревший факел не осветит путь, пустой взгляд не найдёт и луны',
            ]},
    ];

    // Triangle tips now with two facets: positive (green) and negative (red)
    const triTips = [
        {
            title:'Вершина духа',
            pos:[
                'Разумный ищет результата',
                'Слово вызывает действие',
                'Удар достигает цели',
            ],
            neg:[
                'Разумный не ищет красоты',
                'Эффективное редко эффектно',
                'Верное не всегда правильно',
            ],
        },
        {
            title:'Правая основа',
            pos:[
                'Разумный примыкает к силе',
                'Поток несёт — плыви',
                'Скала стоит — обойди',
            ],
            neg:[
                'Разумный не объявляет войны',
                'Противостояние не цель',
                'Победа без побеждённых',
            ],
        },
        {
            title:'Левая основа',
            pos:[
                'Разумный слушает',
                'Мнения — ключи душ',
                'Чуждое — пища ума',
            ],
            neg:[
                'Разумный не проповедует',
                'Знания — ценный дар',
                'Копия — вечный конкурент',
            ],
        },
    ];

    function svgToClient(pt){
        const p = svg.createSVGPoint(); p.x = pt.x; p.y = pt.y;
        const s = p.matrixTransform(svg.getScreenCTM());
        return { x:s.x, y:s.y };
    }

    function renderTipHTML(tip){
        // If tip has pos/neg, render dual facets; else render single text.
        if (tip.pos || tip.neg){
            return `
                <div class="facets">
                    ${tip.pos ? `<div class="facet pos"><div class="label">${tip.pos[0]}</div><div>${tip.pos[1]}</div><div>${tip.pos[2]}</div></div>` : ''}
                    ${tip.neg ? `<div class="facet neg"><div class="label">${tip.neg[0]}</div><div>${tip.neg[1]}</div><div>${tip.neg[2]}</div></div>` : ''}
                </div>
            `;
        }
        return `<h4>${tip.text[0]}</h4><p>${tip.text[1] ?? ''}</p>`;
    }

    function showTip(tip, pt){
        const c = svgToClient(pt);
        tooltipEl.innerHTML = renderTipHTML(tip);
        tooltipEl.style.left = c.x + 'px';
        tooltipEl.style.top  = c.y + 'px';
        tooltipEl.classList.add('show');
        const rect = tooltipEl.getBoundingClientRect();
        tooltipEl.style.transform = (rect.bottom > window.innerHeight - 8)
            ? 'translate(-50%,-26px)' : 'translate(-50%,-18px)';
    }
    function hideTip(){ tooltipEl.classList.remove('show'); }

    function addVertex(point, tip, runeKind){
        const g = document.createElementNS("http://www.w3.org/2000/svg",'g');
        g.setAttribute('class', 'vertex');
        g.setAttribute('tabindex','0');
        g.setAttribute('role','button');
        g.setAttribute('aria-label', tip.title);
        g.setAttribute('transform', `translate(${point.x} ${point.y})`);
        const hit  = document.createElementNS("http://www.w3.org/2000/svg",'circle');
        hit.setAttribute('class','hit'); hit.setAttribute('r','22');
        const glow = document.createElementNS("http://www.w3.org/2000/svg",'circle');
        glow.setAttribute('class','glow'); glow.setAttribute('r','20');
        const rune = document.createElementNS("http://www.w3.org/2000/svg",'g');
        rune.setAttribute('class','rune');
        runes[runeKind](rune, 13 + Math.random()*4);
        g.append(hit, glow, rune);

        const enter = ()=> showTip(tip, point);
        const leave = ()=> hideTip();
        g.addEventListener('mouseenter', enter);
        g.addEventListener('mouseleave', leave);
        g.addEventListener('focusin', enter);
        g.addEventListener('focusout', leave);
        g.addEventListener('click', (e)=>{
            if (g.classList.contains('active')) { g.classList.remove('active'); hideTip(); }
            else { [...verticesLayer.children].forEach(v=>v.classList.remove('active')); g.classList.add('active'); showTip(tip, point); }
            e.stopPropagation();
        });

        verticesLayer.appendChild(g);
    }

    hexPts.forEach((p,i)=> addVertex(p, hexTips[i], runeOrder[i%runeOrder.length]));
    triPts.forEach((p,i)=> addVertex(p, triTips[i], runeOrder[(i+2)%runeOrder.length]));

    window.addEventListener('resize', hideTip);
    document.body.addEventListener('click', ()=>{
        [...verticesLayer.children].forEach(v=>v.classList.remove('active'));
        hideTip();
    });

    /* ===== Floating glyphs (intense spread) ===== */
    const floatLayer = document.getElementById('floatLayer');
    const backdrop = ['◊','✦','Ϟ','ꙮ','✶','ᚠ','ᛝ','☿','✹','✧','☉','☄','℧'];
    const COUNT = 46;
    const rootStyle = getComputedStyle(document.documentElement);
    const glyphMin = parseInt(rootStyle.getPropertyValue('--glyph-min'));
    const glyphMax = parseInt(rootStyle.getPropertyValue('--glyph-max'));
    for(let i=0;i<COUNT;i++){
        const s = document.createElement('div');
        s.className='glyph';
        s.textContent = backdrop[Math.floor(Math.random()*backdrop.length)];

        const size = glyphMin + Math.random() * (glyphMax - glyphMin);
        s.style.fontSize = size.toFixed(0)+'px';

        s.style.left = (Math.random()*96+2)+'%';
        const driftVW = (Math.random()*2-1) * (12 + Math.random()*34);
        s.style.setProperty('--dx', driftVW.toFixed(1) + 'vw');

        const dur = 12 + Math.random()*20;
        const delay = Math.random()*-dur;
        s.style.animationDuration = `${dur}s, ${2.6+Math.random()*2.8}s`;
        s.style.animationDelay = `${delay}s, ${Math.random()*-4}s`;

        floatLayer.appendChild(s);
    }
</script>
</body>
</html>
